================================================================================
=                                                                              =
=                          Manuel utilisateur de SEM                           =
=                                                                              =
================================================================================




================================================================================
* O/ Préface
================================================================================


--------------------------------------------------------------------------------
** O/ 1- présentation du logiciel
--------------------------------------------------------------------------------

  Segmenteur Étiqueteur Markovien (SEM) est un logiciel d'annotation syntaxique
  du français.
  
  Il permet la segmentation de texte brut en phrases, elles-même
  découpées en unités lexicales, mais il est tout-à-fait en mesure de traiter
  un texte pré-segmenté. Les unités multi-mots peuvent être gérées de deux
  manières différentes : soit comme une seule unité lexicale où chaque mot est
  relié par le caractère '_', soit comme une suite de mots ayant une annotation
  particulière précisant que les mots sont reliés entre eux et possèdent
  globalement la même fonction syntaxique.
  
  SEM propose deux niveaux d'annotation syntaxique : le premier est une
  annotation morpho-syntaxique de chaque unité lexicale du texte selon le jeu
  d'étiquettes défini par Crabbé et Candito (TALN 2008). Le second est une
  annotation en chunks selon le modèle BIO (Begin In Out), le programme
  permettant d'obtenir un étiquetage selon un chunking complet ou bien partiel,
  auquel cas il ne reconnaîtra que les groupes nominaux (le chunking partiel
  étant soumis à des règles différentes que le chunking complet, l'un n'est donc
  pas un sous-ensemble de l'autre).
  

--------------------------------------------------------------------------------
** O/ 2- les commandes
--------------------------------------------------------------------------------

  Toutes les commandes du manuel sont mises entre guillemets pour les distinguer
  clairement du reste du texte, mais elle doit être écrite sans eux.

================================================================================
* I/ Installation
================================================================================

  Sur la page suivante se trouvent toutes les informations nécessaires :
  https://code.launchpad.net/~yoann-dupont/crftagger/stand-alone-tagger

  À partir de là, deux possibilités pour télécharger la dernière version :


--------------------------------------------------------------------------------
** I/ 1- si bazaar est installé
--------------------------------------------------------------------------------

  Il faut alors aller dans un terminal et taper la commande suivante :
  bzr branch lp:~yoann-dupont/crftagger/stand-alone-tagger

  Cela va créer un dossier stand-alone-tagger dans le répertoire où est tapée la
  commande.

  Il s'agit de la branche bazaar (dépôt), qui sert à gérer les différentes
  versions du logiciel. Il ne faut en AUCUN cas modifier le contenu de ce
  dossier (c'est surtout vrai si on prévoit de mettre-à-jour la branche, mais
  c'est une habitude à prendre immédiatement). Pour utiliser SEM, il faut copier
  les différents fichiers et dossiers dans un autre répertoire. Un dossier .bzr
  est présent : étant caché il ne sera pas copié si on n'active pas l'affichage
  des fichiers cachés, sinon il faut le déselectionner. C'est ce dossier qui
  contient les informations de versionnement.

  L'intérêt ici est de pouvoir mettre-à-jour simplement le logiciel en tapant la
  commande "bzr up" dans la branche. Cela mettra à jour uniquement les fichiers
  qui doivent l'être, ce qui est pratique quand (comme ici) le contenu est assez
  lourd.

--------------------------------------------------------------------------------
** I/ 2- si bazaar n'est pas installé
--------------------------------------------------------------------------------

  Sur https://code.launchpad.net/~yoann-dupont/crftagger/stand-alone-tagger
  il faut descendre jusqu'à atteindre la partie "recent revisions" et
  télécharger la dernière version disponible. Pour ce faire, il faut cliquer sur
  le numéro de révision qui va mener sur une nouvelle page. Il suffit alors de
  cliquer sur "download tarball" pour obtenir la dernière révision.

  L'avantage de cette méthode est qu'il s'agit des fichiers non-versionnés, il
  n'est donc pas nécessaire d'être aussi précautionneux avec le contenu du
  dossier. L'inconvénient est que pour mettre à jour, il faut tout
  retélécharger.

--------------------------------------------------------------------------------
** I/ 3- Wapiti
--------------------------------------------------------------------------------

  La dernière version de wapiti compatible avec SEM est disponible dans le
  dossier ext. Les consignes d'intallation sont disponibles avec.
  
  Supposons que stand-alone-tagger se trouve dans le dossier foobar à la racine.
  Sous Linux, son chemin absolu est donc $HOME/foobar ou ~/foobar
  stand-alone-tagger se trouve donc à l'emplacement ~/foobar/stand-alone-tagger
  
  Dans le dossier ~/foobar/stand-alone-tagger/ext se trouve une archive de la
  forme wapiti-X.tar.gz où X est un numéro de version. Il faut extraire cette
  archive dans le dossier même. Cela crééra un dossier nommé wapiti-X.
  
  dans le dossier ~/foobar/stand-alone-tagger/ext/wapiti-X, tapez la commande
  "make" pour créer l'exécutable wapiti.
  
---------------------------------------------------
*** I/ 3- 1. Vous avez les droits d'administrateurs
---------------------------------------------------

  Tapez la commande "sudo make install" pour terminer l'installation de wapiti.
  
---------------------------------------------------------
*** I/ 3- 2. Vous n'avez pas les droits d'administrateurs
---------------------------------------------------------

  Il faut alors ajouter le dossier où se trouve l'exécutable wapiti à la
  variable PATH. Il est préférable de d'abord créer une copie de cette variable
  via la commande "PATH_OLD=$PATH". Il faut ensuite ajouter le dossier à la fin
  de la variable PATH via la commande
  "PATH=$PATH:~/foobar/stand-alone-tagger/ext/wapiti-X". S'il y a eu une erreur
  dans la commande de rajout du dossier à la variable PATH, il suffit de
  restaurer sa valeur de base via la commande "PATH=$PATH_OLD".
  
  /!\ Les modifications faites à la variables PATH ne sont valables que dans le
  terminal où elles sont écrites et ne perdurent pas après la fermeture de ce
  dernier. Il faut donc refaire cette étape à chaque nouveau terminal ouvert.
  
-----------------------------------
*** I/ 3- 3. Erreurs de compilation
-----------------------------------

  Wapiti est un logiciel ayant recours à certaines spécificités du matériel et
  du système d'exploitation pour améliorer ses performances. En conséquence, il
  est possible d'avoir des erreurs à l'étape I/3- étant dues à l'abscence de ces
  spécificités sur votre machine.
  
  La plus fréquente semble être dûe à la fonction "__sync_bool_compare_and_swap"
  présente dans le fichier "gradient.c". Si la commande make provoque une erreur
  et vous affiche des messages relatifs à cette fonction, la procédure est très
  simple.
  Dans le fichier "wapiti.h", cherchez la ligne :
  //#define ATM_ANSI
  Et supprimez la chaîne "//" en début de ligne pour obtenir :
  #define ATM_ANSI
  Sauvegardez et reprenez la procédure d'installation.

--------------------------------------------------------------------------------
** I/ 4- Les fichiers modèles
--------------------------------------------------------------------------------

  Avant d'utiliser SEM, il est nécessaire de décompresser les fichiers modèles
  qui se trouvent dans le dossier resources de stand-alone-tagger. Pour
  reprendre l'illustration de 1/3-, l'archive models.tar.gz se trouve dans le
  dossier : ~/foobar/stand-alone-tagger/resources. Il faut l'extraire dans le
  dossier même.




================================================================================
* II/ Utilisation
================================================================================

  SEM est un script python qu'il faut lancer dans un terminal. La commander est
  la suivante :

  python sem_tagger.py <<fichier>>

  Où <<fichier>> est le chemin vers le fichier de configuration choisi pour
  paramétrer SEM.

--------------------------------------------------------------------------------
** II/ 1- fichier de configuration
--------------------------------------------------------------------------------

  Le fichier de configuration se veut aussi simple et direct que possible.

  On dispose d'un ensemble de paramètres identifiés par leur nom. Pour dire
  qu'on assigne une valeur à un paramètre, il suffit d'écrire l'identifiant du
  paramètre et d'écrire sa valeur à la ligne suivante. Les identifiants sont
  sensibles à la casse. Par défaut, ces valeurs sont unitaires, chaque paramètre
  dispose donc d'une seule et unique valeur.
  Pour les paramètres qui représentent des ensembles, il faut mettre l'ensemble
  des valeurs les unes à la suite des autres en les séparant par soit un espace
  soit par un retour à la ligne.
  D'autres paramètres représentent un booléen, c'est-à-dire une valeur qui est
  soit vraie soit fausse. Pour qu'une propriété booléene soit vraie, on peut lui
  donner comme valeur : Y, YES ou TRUE. Pour qu'une valeur soit fausse, on écrit
  N, NO, FALSE. Les valeurs booléenes sont insensibles à la casse.

  Le caractère marquant le commentaire est le #. Si une ligne commence par un #,
  elle est ignorée. Une ligne n'est lue que jusqu'au premier # rencontré.

  Les différents paramètres sont listés ci-dessous :
    IN_FILE : le fichier en entrée. Il s'agit du fichier sur lequel on souhaite
              effectuer le traitement.

    OUT_DIRECTORY : le répertoire de sortie. L'ensemble des fichiers générés par
                    SEM seront placés dans ce répertoire. Il doit exister avant
                    l'exécution du script car il ne sera pas créé dans le cas
                    contraire.

    SEGMENTATION (booléen) : le fichier en entrée est-il du texte brut ayant
                             besoin d'être segmenté ? La segmentation a été
                             faite manuellement et n'est pas forcément parfaite
                             (problème avec le point), ce qui peut perturber
                             l'étiqueteur.

    LEFFF_FILE : le dictionnaire Lefff. Il s'agit d'un fichier où sont
                 répertoriés les mots avec leurs potentielles étiquettes POS
                 dans un format lisible par python.

    POS_TAGS (ensemble) : les différentes étiquettes POS. Chaque étiquette doit
                          être écrite.

    CHUNK_TAGS (ensemble) : les différents identifiants de chunk. Les marqueurs
                            de position (B- et I-) ne doivent pas être écrits
                            car ils sont ajoutés automatiquement. Peu importe la
                            valeur donnée à ce paramètre, on dispose toujours
                            des étiquettes B, I et O.

    CODE : il s'agit du code désignant la tâche à effectuer. Soit un étiquetage
           POS, soit chunk, soit les deux. L'étiquetage POS se désigne par POS,
           chunk par CHUNK et effectuer le POS suivi du chunk par POS+CHUNK. Les
           valeurs ne sont pas sensibles à la casse, mais l'ordre est important,
           car les tâches sont effectuées dans l'ordre de leur énumération.

    MODELS : Le(s) vers le(s) modèle(s) à utiliser. Si plusieurs modèles doivent
             être utilisés, ils faut les places les uns à la suite des autres en
             les séparant par le caractère +. La convention est identique à
             celle du paramètre CODE et chaque modèle doit correspondre au code.
             Par exemple, nous disposons du code POS+CHUNK et nous avons deux
             modèles : mp (pour le POS) et mc (pour le chunk). Le code modèle
             correspondant à cette tâche est donc mp+mc.

    CLEAN (booléen) : les fichiers intermédiaires doivent-il êtres supprimés ?

    HAS_TAGGING (booléen) : disposons-nous d'un étiquetage correspondant au
                            code ?

    INPUT_ENCODING : l'encodage du fichier en entrée (ANSI, latin-1, UTF-8,
                     etc...)

    OUTPUT_ENCODING : l'encodage des fichiers de sortie.

    QUIET (booléen) : le terminal doit-il fournir un retour ? (Ne permet pas de
                      supprimer la sortie de wapiti)




================================================================================
* III/ Exemples
================================================================================

  Différents exemples illustrant ce que l'on peut faire avec SEM.

  Dans les exemples suivants, le terminal fournit un retour et les fichiers
  intermédiaires ne sont pas supprimés. Le chunking employé est le chunking
  nominal uniquement.

  Note importante : les dossiers contenus dans l'archive example doivent être
  mis à la racine de SEM pour assurer leur bon fonctionnement.

--------------------------------------------------------------------------------
** III/ 1- Étiquetage POS à partir d'un texte brut
--------------------------------------------------------------------------------

  Dans un terminal...
  python sem_tagger.py config/POS-plaintext

--------------------------------------------------------------------------------
** III/ 2- Étiquetage POS à partir d'un texte pré-formaté
--------------------------------------------------------------------------------

  Dans un terminal...
  python sem_tagger.py config/POS-segmentedtext

--------------------------------------------------------------------------------
** III/ 3- Étiquetage POS à partir d'un texte pré-formaté en utilisant le Lefff
--------------------------------------------------------------------------------

  (ndr : pour une raison que j'ignore, ce modèle fonctionne très mal... Je
  le changerai dès que possible.)

  Dans un terminal...
  python sem_tagger.py config/POS-LEFFF-segmentedtext

--------------------------------------------------------------------------------
** III/ 4- Étiquetage chunk à partir d'un texte pré-formaté et étiqueté en POS
--------------------------------------------------------------------------------

  Dans un terminal...
  python sem_tagger.py config/CHUNK-taggedtext

--------------------------------------------------------------------------------
** III/ 5- Étiquetage POS puis chunk à partir d'un texte brut
--------------------------------------------------------------------------------

  Dans un terminal...
  python sem_tagger.py config/POS-CHUNK-plaintext

--------------------------------------------------------------------------------
** III/ 6- Étiquetage POS puis chunk à partir d'un texte pré-formaté
--------------------------------------------------------------------------------

  Dans un terminal...
  python sem_tagger.py config/POS-CHUNK-segmentedtext
